#!/usr/bin/env python

import rospy
import numpy as np
from geometry_msgs.msg import TwistStamped, Twist, Vector3
from std_msgs.msg import Float64MultiArray
from relaxed_ik.msg import EEPoseGoals
import random
import copy
from datetime import datetime
import os
from threading import Thread

########################################
# NOTE: This node generates delta_pose (x,y,z,r,p,y) based on any existing end effector pose (i.e. relative position-based control)      
############ User Setting ##############
mode = 2
pub_rate = 250
### For Mode 1 (Eight-shape moving) 
xyzrpy = [0.0, 0.4, 0.1, 0.0, 0.0, 0.0]    # (m/s) XYZ velocity // (rad) Amplitudes of Roll Pitch Yaw in End Effector Frame
moving_period = [4, 8, 4, 0.0, 0.0, 0.0]     # Repeatative moving period (sec)
### For Mode 2 (Random left and right, and back)
left_range = [0.2, 0.7, -0.3, -0.5, 0.1, 0.6]   # (x_min, x_max, y_min, y_max, z_min, z_max)
right_range = [0.2, 0.7, 0.3, 0.5, 0.1, 0.6]    # (x_min, x_max, y_min, y_max, z_min, z_max)
max_del_x = 0.0001
moving_period_mode_two = 4.0 # (sec)
ee_pose_now = []
min_dist_to_obs_now = []
x = 0.0
y = 0.0
z = 0.0


def main():
  rospy.init_node('virtual_teleoperator')

  # Initisalisation for an publisher
  cmd_publisher = rospy.Publisher('unity/twist1', Twist)
  rospy.sleep(0.5) 

  # Set a scenario of the virtual teloperator movement (Note that the values are relative to the previous point)
  waypoints = []
  waypoints.append((0.5, 0.0, 0.0))
  waypoints.append((-0.5, 0.0, 0.0))
  
  print("Waiting for ROS Time")
  while rospy.get_time() == 0: # Waiting for receiving the first message from /clock
    pass
  time_0 = rospy.get_rostime()
  print("Got ROS Time")

  if mode == 2:
    rospy.Subscriber('/relaxed_ik/ee_pose_now', EEPoseGoals, cb_ee_pose_now)
    rospy.Subscriber('/relaxed_ik/min_dist_to_obs', Float64MultiArray, cb_min_dist_to_obs)

    print("Waiting for End Effector Position")
    while len(ee_pose_now) == 0: # Waiting for receiving the first message from /relaxed_ik/ee_pose_now
      pass    
    print("Got End Effector Position")
    flag_new_target = 1 # This becomes one when the robot needs to change its moving direction, then becomes zero again.
    ee_pose_init = copy.deepcopy(ee_pose_now)

    # Output file initialisation
    output_filename = "MinDistance_" + str(int(time_0.to_time())) + ".txt"
    f = open(output_filename, "w")
    now = datetime.now()
    # Textual month, day and year	
    f.write("Generated by virtual_teleoperator.py with mode = 2 (" + str(now)+ ")\n")
    
    # Start recording the publish rate
    output_filename = "PubRate_" + str(int(time_0.to_time())) + ".txt"
    x = Thread(target=start_recording_pubrate, args = [output_filename])
    x.start()



  # Publish the virtual user commands
  rate = rospy.Rate(pub_rate)

  while not rospy.is_shutdown():
    time_now = rospy.get_rostime()
    time_step = (time_now - time_0).to_sec()

    if mode == 1: ### For Mode 1 (Eight-shape moving) 
          x = xyzrpy[0]*np.sin(2*np.pi*time_step/moving_period[0])
          y = xyzrpy[1]*np.sin(2*np.pi*time_step/moving_period[1])
          z = xyzrpy[2]*np.sin(2*np.pi*time_step/moving_period[2])
           
    elif mode == 2: ### For Mode 2 (Random right, and back) + Analysis 
          global x, y, z
          if flag_new_target == 1:
            flag_new_target = 0
            goal = gen_random_goal(right_range)
            list_min_dist_to_obs = []

          delta_pose = goal - ee_pose_init
          x = delta_pose[0]*np.sin(2*np.pi*time_step/moving_period_mode_two)
          y = delta_pose[1]*np.sin(2*np.pi*time_step/moving_period_mode_two)
          z = delta_pose[2]*np.sin(2*np.pi*time_step/moving_period_mode_two)
          
          if len(min_dist_to_obs_now) is not 0:  
            _min_dist_to_obs = copy.deepcopy(min_dist_to_obs_now)
            list_min_dist_to_obs.append(min(_min_dist_to_obs))
   
          if time_step >= moving_period_mode_two/2:
            flag_new_target = 1
            time_0 = rospy.get_rostime()
            if len(min_dist_to_obs_now) is not 0:         
              print("Min Dist = ", min(list_min_dist_to_obs))
              f.write(str(min(list_min_dist_to_obs))+"\n")

    
    palm_del_distance = Twist(linear = Vector3(x, y, z))


    cmd_publisher.publish(palm_del_distance)
    rate.sleep()

  
def cb_ee_pose_now(data):
    global ee_pose_now
    ee_pose_now = np.array([data.ee_poses[0].position.x, data.ee_poses[0].position.y, data.ee_poses[0].position.z])

def gen_random_goal(xyz_range):
    goal = np.array([random.uniform(xyz_range[0], xyz_range[1]), random.uniform(xyz_range[2], xyz_range[3]), random.uniform(xyz_range[4], xyz_range[5])])
    return goal

def cb_min_dist_to_obs(data):
    global min_dist_to_obs_now
    min_dist_to_obs_now = []
    for a in data.data:
        min_dist_to_obs_now.append(a)    

def start_recording_pubrate(output_filename):
    os.system("rostopic hz relaxed_ik/joint_angle_solutions --window=1000 > " + output_filename)

if __name__ == '__main__':
  main()