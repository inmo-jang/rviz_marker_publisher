#!/usr/bin/env python

import rospy
import numpy as np
from geometry_msgs.msg import TwistStamped, Twist, Vector3
from std_msgs.msg import Float64MultiArray
from relaxed_ik.msg import EEPoseGoals
import random
import copy
from datetime import datetime
import os
from threading import Thread
from gen_obstacles import gen_multiple_spheres_in_rviz
from visualization_msgs.msg import Marker, MarkerArray

########################################
# NOTE: This node generates delta_pose (x,y,z,r,p,y) based on any existing end effector pose (i.e. relative position-based control)      
############ User Setting ##############
mode = 3
pub_rate = 250
### For Mode 1 (Eight-shape moving) 
xyzrpy = [0.0, 0.4, 0.1, 0.0, 0.0, 0.0]    # (m/s) XYZ velocity // (rad) Amplitudes of Roll Pitch Yaw in End Effector Frame
moving_period = [4, 8, 4, 0.0, 0.0, 0.0]     # Repeatative moving period (sec)
### For Mode 2 (Random left and right, and back)
# left_range = [0.2, 0.7, -0.3, -0.5, 0.1, 0.6]   # (x_min, x_max, y_min, y_max, z_min, z_max)
right_range = [0.2, 0.7, 0.5, 0.6, 0.2, 0.7]    # (x_min, x_max, y_min, y_max, z_min, z_max)
max_del_x = 0.0001
moving_period_mode_two = 3.0 # (sec)
### For Mode 3 (Forward and Backward)
xyzrpy_mode3 = [0.0, 0.0, -0.2, 0.0, 0.0, 0.0]    # (m/s) XYZ velocity // (rad) Amplitudes of Roll Pitch Yaw in End Effector Frame
moving_period_mode3 = [30, 8, 30, 0.0, 0.0, 0.0]     # Repeatative moving period (sec)
# Followings are initialisation
ee_pose_goal = []
ee_pose_now = []
min_dist_to_obs_now = []
x = 0.0
y = 0.0
z = 0.0


def main():
  rospy.init_node('virtual_teleoperator')

  # Initisalisation for an publisher
  cmd_publisher = rospy.Publisher('unity/twist1', Twist)
  rospy.sleep(0.5) 

  # Set a scenario of the virtual teloperator movement (Note that the values are relative to the previous point)
  waypoints = []
  waypoints.append((0.5, 0.0, 0.0))
  waypoints.append((-0.5, 0.0, 0.0))
  
  print("Waiting for ROS Time")
  while rospy.get_time() == 0: # Waiting for receiving the first message from /clock
    pass
  time_0 = rospy.get_rostime()
  print("Got ROS Time")

  if mode == 2:
    rospy.Subscriber('/relaxed_ik/ee_pose_now', EEPoseGoals, cb_ee_pose_now)
    rospy.Subscriber('/relaxed_ik/min_dist_to_obs', Float64MultiArray, cb_min_dist_to_obs)

    print("Waiting for End Effector Position")
    while len(ee_pose_now) == 0: # Waiting for receiving the first message from /relaxed_ik/ee_pose_now
      pass    
    print("Got End Effector Position")
    flag_new_target = 1 # This becomes one when the robot needs to change its moving direction, then becomes zero again.
    ee_pose_init = copy.deepcopy(ee_pose_now)

    # Output file initialisation
    output_filename = "MinDistance_" + str(int(time_0.to_time())) + ".txt"
    f = open(output_filename, "w")
    now = datetime.now()
    # Textual month, day and year	
    f.write("Generated by virtual_teleoperator.py with mode = 2 (" + str(now)+ ")\n")
    
    # Start recording the publish rate
    output_filename = "PubRate_" + str(int(time_0.to_time())) + ".txt"
    x = Thread(target=start_recording_pubrate, args = [output_filename])
    x.start()

    # Obstacle Publisher setting
    marker_array_publisher = rospy.Publisher('visualization_marker_array', MarkerArray)
    # Marker Array setting
    radius = 0.1
    num_obstacles = 1000 
    range_obstacles = (-0.1, 0.9, 0.30, 0.50, 0.0, 1.0) # It should include (x_min, x_max, y_min, y_max, z_min, z_max)    
    

  elif mode == 3:
    rospy.Subscriber('/relaxed_ik/ee_pose_goals', EEPoseGoals, cb_ee_pose_goal)
    rospy.Subscriber('/relaxed_ik/ee_pose_now', EEPoseGoals, cb_ee_pose_now)
    rospy.Subscriber('/relaxed_ik/min_dist_to_obs', Float64MultiArray, cb_min_dist_to_obs)        
    print("Waiting for End Effector Position")
    while len(ee_pose_now) == 0: # Waiting for receiving the first message from /relaxed_ik/ee_pose_now
      pass    
    print("Got End Effector Position")

    # Output file initialisation
    output_filename = "Trajectory_" + str(int(time_0.to_time())) + ".txt"
    f = open(output_filename, "w")
    now = datetime.now()
    # Textual month, day and year	
    f.write("Generated by virtual_teleoperator.py with mode = 3 (" + str(now)+ ")\n")
    f.write("Time\tEnd-effector Position(Ref)\tEnd-effector Position(Now)\tMinimum Distacne to Obstacles")


  # Publish the virtual user commands
  rate = rospy.Rate(pub_rate)
  epoch = 0
  while not rospy.is_shutdown():
    time_now = rospy.get_rostime()
    time_step = (time_now - time_0).to_sec()

    if mode == 1: ### For Mode 1 (Eight-shape moving) 
          x = xyzrpy[0]*np.sin(2*np.pi*time_step/moving_period[0])
          y = xyzrpy[1]*np.sin(2*np.pi*time_step/moving_period[1])
          z = xyzrpy[2]*np.sin(2*np.pi*time_step/moving_period[2])
           
    elif mode == 2: ### For Mode 2 (Random right, and back) + Analysis 
          global x, y, z
          if flag_new_target == 1:
            flag_new_target = 0
            goal = gen_random_goal(right_range)
            list_min_dist_to_obs = []
            # Generate a marker array accordingly
            sphere_array = gen_multiple_spheres_in_rviz(radius, num_obstacles, range_obstacles)
            marker_array_publisher.publish(sphere_array)

          delta_pose = goal - ee_pose_init
          x = delta_pose[0]*np.sin(2*np.pi*time_step/moving_period_mode_two)
          y = delta_pose[1]*np.sin(2*np.pi*time_step/moving_period_mode_two)
          z = delta_pose[2]*np.sin(2*np.pi*time_step/moving_period_mode_two)
          
          if len(min_dist_to_obs_now) is not 0:  
            _min_dist_to_obs = copy.deepcopy(min_dist_to_obs_now)
            list_min_dist_to_obs.append(min(_min_dist_to_obs))
   
          if time_step >= moving_period_mode_two/2:
            flag_new_target = 1
            time_0 = rospy.get_rostime()
            if len(min_dist_to_obs_now) is not 0:
              epoch += 1         
              print("Epoch = ", str(epoch), "; Min Dist = ", min(list_min_dist_to_obs))
              f.write(str(min(list_min_dist_to_obs))+"\n")

    elif mode ==3: ## For Mode 3
          # Time
          f.write(str(time_step)+"\t") 
          # End Effector Ref
          if len(ee_pose_goal) is 3:
            __ee_pose_goal = copy.deepcopy(ee_pose_goal)
            f.write(str(round(__ee_pose_goal[0], 9))+"\t")
            f.write(str(round(__ee_pose_goal[1], 9))+"\t")
            f.write(str(round(__ee_pose_goal[2], 9))+"\t")

          # End Effector Now
          if len(ee_pose_now) is 3:
            __ee_pose_now = copy.deepcopy(ee_pose_now)
            f.write(str(round(__ee_pose_now[0], 9))+"\t")
            f.write(str(round(__ee_pose_now[1], 9))+"\t")
            f.write(str(round(__ee_pose_now[2], 9))+"\t")


          # Min distance to any obstacle
          if len(min_dist_to_obs_now) is 6: 
            _min_dist_to_obs = copy.deepcopy(min_dist_to_obs_now)
            f.write(str(round(_min_dist_to_obs[0], 9))+"\t")
            f.write(str(round(_min_dist_to_obs[1], 9))+"\t")
            f.write(str(round(_min_dist_to_obs[2], 9))+"\t")
            f.write(str(round(_min_dist_to_obs[3], 9))+"\t")
            f.write(str(round(_min_dist_to_obs[4], 9))+"\t")
            f.write(str(round(_min_dist_to_obs[5], 9))+"\t")
          f.write("\n")

          x = xyzrpy_mode3[0]*np.sin(2*np.pi*time_step/moving_period_mode3[0])
          y = xyzrpy_mode3[1]*np.sin(2*np.pi*time_step/moving_period_mode3[1])
          z = xyzrpy_mode3[2]*np.sin(2*np.pi*time_step/moving_period_mode3[2])



    palm_del_distance = Twist(linear = Vector3(x, y, z))


    cmd_publisher.publish(palm_del_distance)
    rate.sleep()

def cb_ee_pose_goal(data):
    global ee_pose_goal
    ee_pose_goal = np.array([data.ee_poses[0].position.x, data.ee_poses[0].position.y, data.ee_poses[0].position.z])

def cb_ee_pose_now(data):
    global ee_pose_now
    ee_pose_now = np.array([data.ee_poses[0].position.x, data.ee_poses[0].position.y, data.ee_poses[0].position.z])

def gen_random_goal(xyz_range):
    goal = np.array([random.uniform(xyz_range[0], xyz_range[1]), random.uniform(xyz_range[2], xyz_range[3]), random.uniform(xyz_range[4], xyz_range[5])])
    return goal

def cb_min_dist_to_obs(data):
    global min_dist_to_obs_now
    min_dist_to_obs_now = []
    for a in data.data:
        min_dist_to_obs_now.append(a)    

def start_recording_pubrate(output_filename):
    os.system("rostopic hz relaxed_ik/joint_angle_solutions --window=1000 > " + output_filename)

if __name__ == '__main__':
  main()